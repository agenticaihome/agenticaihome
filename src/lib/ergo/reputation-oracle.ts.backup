import {
  TransactionBuilder,
  OutputBuilder,
  ErgoAddress,
  SConstant,
  SSigmaProp,
  SGroupElement,
  SByte,
  SColl,
  SInt,
  SLong,
} from '@fleet-sdk/core';
import { getCurrentHeight, getBoxesByAddress, getBoxById } from './explorer';
import { MIN_BOX_VALUE, RECOMMENDED_TX_FEE, PLATFORM_FEE_ADDRESS } from './constants';

// ─── Reputation Oracle Contract ─────────────────────────────────────

/**
 * ErgoScript: Reputation Oracle Contract
 *
 * This contract implements a decentralized reputation oracle system where
 * AgenticAiHome can publish agent reputation data on-chain for other dApps to read.
 * Other smart contracts can use these boxes as "data inputs" (read-only) to 
 * access reputation scores without spending the boxes.
 *
 * Register Layout:
 * R4: Coll[Byte] - Agent's public key (33 bytes)
 * R5: Long       - Agent's EGO score (cumulative reputation points)
 * R6: Int        - Total tasks completed by agent
 * R7: Int        - Dispute rate (basis points, e.g., 250 = 2.5%)
 * R8: Int        - Last updated block height
 * R9: Coll[Byte] - Agent's identity hash (for privacy-preserving queries)
 *
 * Only the AgenticAiHome treasury can update these oracle boxes.
 * The box value is kept minimal (just above dust limit).
 * Anyone can read the data by referencing these boxes as data inputs.
 */
export const REPUTATION_ORACLE_ERGOSCRIPT = `{
  // Extract the treasury's public key from constants (hardcoded at compile time)
  val treasuryPubKey = treasuryPK
  
  // Extract current reputation data from registers
  val agentPubKey = SELF.R4[Coll[Byte]].get
  val egoScore = SELF.R5[Long].get
  val tasksCompleted = SELF.R6[Int].get
  val disputeRate = SELF.R7[Int].get
  val lastUpdated = SELF.R8[Int].get
  val agentIdentityHash = SELF.R9[Coll[Byte]].get
  
  // Validate that this is a legitimate update by the treasury
  val treasuryApproval = treasuryPubKey
  
  // For oracle updates: ensure output maintains the same structure with updated data
  val validOracleUpdate = OUTPUTS.exists { (output: Box) =>
    // Same contract address (oracle structure preserved)
    output.propositionBytes == SELF.propositionBytes &&
    // Minimum box value maintained
    output.value >= SELF.value &&
    // Agent identity preserved (R4 and R9 cannot change)
    output.R4[Coll[Byte]].get == agentPubKey &&
    output.R9[Coll[Byte]].get == agentIdentityHash &&
    // Updated timestamp (R8 must be >= current)
    output.R8[Int].get >= lastUpdated &&
    // All required registers present
    output.R5[Long].isDefined &&
    output.R6[Int].isDefined &&
    output.R7[Int].isDefined
  }
  
  // Only treasury can update oracle data
  treasuryApproval && validOracleUpdate
}`;

/**
 * Pre-compiled P2S address for the reputation oracle contract.
 * NOTE: Needs compilation via node.ergo.watch
 * This address will be populated after compilation with the treasury public key.
 */
export let REPUTATION_ORACLE_CONTRACT_ADDRESS = '';

// ─── Types ───────────────────────────────────────────────────────────

export interface ReputationOracleData {
  agentPubKey: Uint8Array;
  egoScore: bigint;
  tasksCompleted: number;
  disputeRate: number; // basis points (0-10000)
  lastUpdated: number;
  agentIdentityHash: Uint8Array;
}

export interface OracleUpdateParams {
  agentAddress: string;
  egoScore: bigint;
  tasksCompleted: number;
  disputeRate: number;
  treasuryUtxos: any[];
  changeAddress: string;
}

// ─── Helper Functions ────────────────────────────────────────────────

/**
 * Extract 33-byte compressed public key from P2PK address
 */
function extractPubKeyFromAddress(address: string): Uint8Array {
  const ergoAddr = ErgoAddress.fromBase58(address);
  const tree = ergoAddr.ergoTree;
  if (!tree.startsWith('0008cd')) {
    throw new Error(`Address ${address} is not a P2PK address`);
  }
  const pubkeyHex = tree.slice(6);
  return Uint8Array.from(Buffer.from(pubkeyHex, 'hex'));
}

/**
 * Generate a privacy-preserving identity hash for an agent.
 * Uses blake2b256(pubKey + salt) to allow anonymous reputation queries.
 */
function generateAgentIdentityHash(pubKey: Uint8Array): Uint8Array {
  // In production, this should include a salt specific to AgenticAiHome
  const salt = new TextEncoder().encode('AGENTICHOME_ORACLE_V1');
  const combined = new Uint8Array(pubKey.length + salt.length);
  combined.set(pubKey);
  combined.set(salt, pubKey.length);
  
  // For now, return a deterministic hash (in production, use blake2b256)
  const hashHex = Array.from(combined)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
    .slice(0, 64); // 32 bytes = 64 hex chars
  
  return Uint8Array.from(Buffer.from(hashHex, 'hex'));
}

// ─── Oracle Creation and Updates ─────────────────────────────────────

/**
 * Create a new reputation oracle box for an agent.
 * This establishes the agent in the on-chain reputation system.
 */
export async function createReputationOracleTx(
  params: OracleUpdateParams
): Promise<any> {
  const {
    agentAddress,
    egoScore,
    tasksCompleted,
    disputeRate,
    treasuryUtxos,
    changeAddress
  } = params;

  // Validate inputs
  if (!agentAddress || agentAddress.length < 10) {
    throw new Error('Invalid agent address');
  }
  if (disputeRate < 0 || disputeRate > 10000) {
    throw new Error('Dispute rate must be between 0 and 10000 basis points');
  }
  if (tasksCompleted < 0) {
    throw new Error('Tasks completed cannot be negative');
  }

  const currentHeight = await getCurrentHeight();
  const agentPubKey = extractPubKeyFromAddress(agentAddress);
  const agentIdentityHash = generateAgentIdentityHash(agentPubKey);

  // Create oracle box with reputation data
  const oracleOutput = new OutputBuilder(MIN_BOX_VALUE, REPUTATION_ORACLE_CONTRACT_ADDRESS)
    .setAdditionalRegisters({
      R4: SConstant(SColl(SByte, agentPubKey)),           // Agent public key
      R5: SConstant(SLong(egoScore)),                     // EGO score
      R6: SConstant(SInt(tasksCompleted)),                // Tasks completed
      R7: SConstant(SInt(disputeRate)),                   // Dispute rate (bp)
      R8: SConstant(SInt(currentHeight)),                 // Last updated
      R9: SConstant(SColl(SByte, agentIdentityHash)),     // Identity hash
    });

  const unsignedTx = new TransactionBuilder(currentHeight)
    .from(treasuryUtxos)
    .to([oracleOutput])
    .sendChangeTo(changeAddress)
    .payFee(RECOMMENDED_TX_FEE)
    .build()
    .toEIP12Object();

  return unsignedTx;
}

/**
 * Update an existing reputation oracle box with new data.
 * Only the treasury can perform these updates.
 */
export async function updateReputationOracleTx(
  existingOracleBoxId: string,
  params: OracleUpdateParams
): Promise<any> {
  const {
    agentAddress,
    egoScore,
    tasksCompleted,
    disputeRate,
    treasuryUtxos,
    changeAddress
  } = params;

  const currentHeight = await getCurrentHeight();
  const existingBox = await getBoxById(existingOracleBoxId);
  
  if (!existingBox) {
    throw new Error('Oracle box not found');
  }

  // Extract existing agent data (R4 and R9 must remain the same)
  const existingAgentPubKey = existingBox.additionalRegisters?.R4;
  const existingIdentityHash = existingBox.additionalRegisters?.R9;
  
  if (!existingAgentPubKey || !existingIdentityHash) {
    throw new Error('Invalid oracle box: missing agent identity data');
  }

  // Create updated oracle box
  const updatedOracleOutput = new OutputBuilder(MIN_BOX_VALUE, REPUTATION_ORACLE_CONTRACT_ADDRESS)
    .setAdditionalRegisters({
      R4: existingAgentPubKey,                            // Agent identity preserved
      R5: SConstant(SLong(egoScore)),                     // Updated EGO score
      R6: SConstant(SInt(tasksCompleted)),                // Updated tasks count
      R7: SConstant(SInt(disputeRate)),                   // Updated dispute rate
      R8: SConstant(SInt(currentHeight)),                 // Updated timestamp
      R9: existingIdentityHash,                           // Identity hash preserved
    });

  const inputs = [existingBox, ...treasuryUtxos];

  const unsignedTx = new TransactionBuilder(currentHeight)
    .from(inputs)
    .to([updatedOracleOutput])
    .sendChangeTo(changeAddress)
    .payFee(RECOMMENDED_TX_FEE)
    .build()
    .toEIP12Object();

  return unsignedTx;
}

// ─── Oracle Data Queries ─────────────────────────────────────────────

/**
 * Find reputation oracle box for a specific agent by their address.
 */
export async function findAgentOracleBox(agentAddress: string): Promise<any | null> {
  try {
    const agentPubKey = extractPubKeyFromAddress(agentAddress);
    const boxes = await getBoxesByAddress(REPUTATION_ORACLE_CONTRACT_ADDRESS);
    
    for (const box of boxes) {
      const boxAgentPubKey = box.additionalRegisters?.R4;
      if (boxAgentPubKey && Buffer.from(boxAgentPubKey, 'hex').equals(agentPubKey)) {
        return box;
      }
    }
    return null;
  } catch (error) {
    console.error('Error finding agent oracle box:', error);
    return null;
  }
}

/**
 * Parse reputation data from an oracle box.
 */
export function parseReputationOracleData(box: any): ReputationOracleData | null {
  try {
    const registers = box.additionalRegisters || {};
    
    if (!registers.R4 || !registers.R5 || !registers.R6 || 
        !registers.R7 || !registers.R8 || !registers.R9) {
      return null;
    }

    return {
      agentPubKey: Uint8Array.from(Buffer.from(registers.R4, 'hex')),
      egoScore: BigInt(registers.R5),
      tasksCompleted: parseInt(registers.R6),
      disputeRate: parseInt(registers.R7),
      lastUpdated: parseInt(registers.R8),
      agentIdentityHash: Uint8Array.from(Buffer.from(registers.R9, 'hex')),
    };
  } catch (error) {
    console.error('Error parsing oracle data:', error);
    return null;
  }
}

/**
 * Get current reputation data for an agent from the oracle.
 */
export async function getAgentReputationFromOracle(agentAddress: string): Promise<ReputationOracleData | null> {
  const oracleBox = await findAgentOracleBox(agentAddress);
  if (!oracleBox) return null;
  
  return parseReputationOracleData(oracleBox);
}

/**
 * Get all agent reputation data from oracle boxes.
 * Useful for displaying leaderboards or analytics.
 */
export async function getAllAgentReputations(): Promise<ReputationOracleData[]> {
  try {
    const boxes = await getBoxesByAddress(REPUTATION_ORACLE_CONTRACT_ADDRESS);
    const reputations: ReputationOracleData[] = [];
    
    for (const box of boxes) {
      const data = parseReputationOracleData(box);
      if (data) {
        reputations.push(data);
      }
    }
    
    return reputations.sort((a, b) => Number(b.egoScore - a.egoScore));
  } catch (error) {
    console.error('Error getting all agent reputations:', error);
    return [];
  }
}

// ─── Integration Helpers ─────────────────────────────────────────────

/**
 * Calculate trust level based on oracle data.
 */
export function calculateTrustLevelFromOracle(data: ReputationOracleData): string {
  const { egoScore, tasksCompleted, disputeRate } = data;
  const egoNumber = Number(egoScore);
  
  if (tasksCompleted < 3) return 'unverified';
  if (egoNumber >= 1000 && disputeRate <= 250 && tasksCompleted >= 20) return 'platinum';
  if (egoNumber >= 500 && disputeRate <= 500 && tasksCompleted >= 10) return 'gold';
  if (egoNumber >= 200 && disputeRate <= 1000 && tasksCompleted >= 5) return 'silver';
  return 'bronze';
}

/**
 * Format reputation score for display.
 */
export function formatReputationScore(data: ReputationOracleData): string {
  const disputeRatePercent = (data.disputeRate / 100).toFixed(1);
  return `EGO: ${data.egoScore} | Tasks: ${data.tasksCompleted} | Disputes: ${disputeRatePercent}%`;
}

// ─── Export utilities ────────────────────────────────────────────────

export {
  extractPubKeyFromAddress as pubkeyFromAddress,
  generateAgentIdentityHash,
};